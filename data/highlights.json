[
  {
    "id": 942583118,
    "text": "The fourth and final subtype is the ambiverted variant of INTJ, and you can consider this the extroverted\n\nintuition subtype. While the previous subtypes do exhibit a strong preference for one function or another, this type is far more neutral, residing closer to the center between the INTJ and the ATP, which is, you know, the same functions just flipped the other way around in orientation. This type tends to experience much less disconnect between the internal and external worlds.",
    "book_id": 55293106
  },
  {
    "id": 942583012,
    "text": "So now, let us dive into the diver subtype of the INTJ, and you can consider this the Ti variant. The diver subtype, as the name implies, is the INTJ who essentially disregards all activated functions in favor of those introverted. Essentially, a person diving right down into the darker senses of their mind. As such, this individual not only enjoys a highly dynamic and diverted feeling, but also extensive dipping into both individual sensing and Introverted thinking, unlike with the divergent subtype of the INTJ, Ti and Si, here, are far from unconscious, but it is important to note they do originate from a NiFi relational existential origin.",
    "book_id": 55293106
  },
  {
    "id": 942581286,
    "text": "now it is time to introduce the divergent INTJ. You can consider this the TE subtype. In this case, rather than pushing into the auxiliary in a kind of tug of war between the auxiliary and authority, the function, as in the case of the convergent value, is different.\n\nThe divergent INTJ bypasses much of FI in full embrace of the extroverted thinking authority.",
    "book_id": 55293106
  },
  {
    "id": 942579192,
    "text": "So first off, I want to start with the convergent INTJ.\n\nYou can loosely consider this the Fi subtype, and this is a subtype that effectively leans into the respective auxiliary function; in this case, introverted feeling. Imagine an individual taking a high degree of ownership over their identity and diving deep into the experiential landscape that is introverted intuition. Intimated feeling, and with introverted feeling here fully activated, there is actually a degree of pull and tug between this function and the type's authority function of extroverted thinking.\n\nIsn't entirely beholden to the pragmatism of that extroverted thinking function and can actually be much more dreamlike and idealistic than the classic INTJ stereotype.",
    "book_id": 55293106
  },
  {
    "id": 942578281,
    "text": "I like to call this attitudinal variation, the fluctuation in our respective convergent and divergent attitudes with respect to our specific cognitive functions.",
    "book_id": 55293106
  },
  {
    "id": 942360956,
    "text": "Sometimes people refer to the individual struc- ture that stores information about a process as a Process Control Block (PCB), a fancy way of talking about a C structure that contains informa- tion about each process (also sometimes called a process descriptor).",
    "book_id": 55275242
  },
  {
    "id": 942360880,
    "text": "Operating systems are replete with various important data structures that we will discuss in these notes. The process list (also called the task list) is the ﬁrst such structure.",
    "book_id": 55275242
  },
  {
    "id": 942360839,
    "text": "You can also see from the ﬁgure that there are some other states a pro- cess can be in, beyond running, ready, and blocked.",
    "book_id": 55275242
  },
  {
    "id": 942360152,
    "text": "We’ll learnmore about this technique known as a context switch in future chapters",
    "book_id": 55275242
  },
  {
    "id": 942358765,
    "text": "// to stop and subsequently restart a process struct context { int eip; int esp; int ebx; int ecx; int edx; int esi; int edi; int ebp; }; // the different states a process can be in enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE }; // the information xv6 tracks about each process // including its register context and state struct proc { char *mem; // Start of process memory uint sz; char *kstack; // Size of process memory // Bottom of kernel stack // for this process enum proc_state state; // Process state int pid; // Process ID struct proc *parent; // Parent process void *chan; // If !zero, sleeping on chan int killed; // If !zero, has been killed struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory struct context context; // Switch here to run process struct trapframe *tf; // Trap frame for the // current interrupt };",
    "book_id": 55275242
  },
  {
    "id": 942358554,
    "text": "The OS is a program, and like any program, it has some key data struc- tures that track various relevant pieces of information. To track the state of each process, for example, the OS likely will keep some kind of pro- cess list for all processes that are ready and some additional informa- tion to track which process is currently running. The OS must also track, in some way, blocked processes; when an I/O event completes, the OS should make sure to wake the correct process and ready it to run again.",
    "book_id": 55275242
  },
  {
    "id": 942314618,
    "text": "These types of decisions are made by the OS scheduler, a topic we will discuss a few chapters in the future.",
    "book_id": 55275242
  },
  {
    "id": 942314219,
    "text": "As you can see in the diagram, a process can be moved between the ready and running states at the discretion of the OS. Being moved from ready to running means the process has been sched- uled; being moved from running to ready means the process has been descheduled. Once a process has become blocked (e.g., by initiating an I/O operation), the OS will keep it as such until some event occurs (e.g., I/O completion); at that point, the process moves to the ready state again (and potentially immediately to running again, if the OS so decides).",
    "book_id": 55275242
  },
  {
    "id": 942313553,
    "text": "• Blocked: In the blocked state, a process has performed some kind of operation that makes it not ready to run until some other event takes place. A common example: when a process initiates an I/O request to a disk, it becomes blocked and thus some other process can use the processor.",
    "book_id": 55275242
  },
  {
    "id": 942313549,
    "text": "• Running: In the running state, a process is running on a processor. This means it is executing instructions.\n\n• Ready: In the ready state, a process is ready to run but for some reason the OS has chosen not to run it at this given moment.",
    "book_id": 55275242
  },
  {
    "id": 942313537,
    "text": "In a simpliﬁed view, a process can be in one of three states:",
    "book_id": 55275242
  },
  {
    "id": 942313520,
    "text": "It thus has one last task: to start the program running at the entry point, namely main(). By jumping to the main() routine (through a specialized mechanism that we will discuss next chapter), the OS transfers control of the CPU to the newly-created process, and thus the program begins its execution.",
    "book_id": 55275242
  },
  {
    "id": 942313436,
    "text": "The OS will also do some other initialization tasks, particularly as re- lated to input/output (I/O). For example, in UNIX systems, each process by default has three open ﬁle descriptors, for standard input, output, and error; these descriptors let programs easily read input from the terminal and print output to the screen. We’ll learn more about I/O, ﬁle descrip- tors, and the like in the third part of the book on persistence.",
    "book_id": 55275242
  },
  {
    "id": 942313305,
    "text": "The OS may also allocate some memory for the program’s heap. In C programs, the heap is used for explicitly requested dynamically-allocated data;",
    "book_id": 55275242
  },
  {
    "id": 942313179,
    "text": "Once the code and static data are loaded into memory, there are a few other things the OS needs to do before running the process. Some mem- ory must be allocated for the program’s run-time stack",
    "book_id": 55275242
  },
  {
    "id": 942312853,
    "text": "paging and swapping",
    "book_id": 55275242
  },
  {
    "id": 942312465,
    "text": "In early (or simple) operating systems, the loading process is done ea- gerly, i.e., all at once before running the program; modern OSes perform the process lazily, i.e., by loading pieces of code or data only as they are needed during programexecution.",
    "book_id": 55275242
  },
  {
    "id": 942312401,
    "text": "The ﬁrst thing that the OS must do to run a program is to load its code and any static data (e.g., initialized variables) into memory, into the ad- dress space of the process. Programs initially reside on disk (or, in some modern systems, ﬂash-based SSDs) in some kind of executable format; thus, the process of loading a program and static data into memory re- quires the OS to read those bytes from disk and place them in memory somewhere (as shown in Figure 4.1).",
    "book_id": 55275242
  },
  {
    "id": 942312389,
    "text": "One mystery that we should unmask a bit is how programs are trans- formed into processes.",
    "book_id": 55275242
  },
  {
    "id": 942312334,
    "text": "• Create: An operating system must include some method to cre- ate new processes. When you type a command into the shell, or double-click on an application icon, the OS is invoked to create a new process to run the program you have indicated.\n\n• Destroy: As there is an interface for process creation, systems also provide an interface to destroy processes forcefully. Of course, many processes will run and just exit by themselves when complete; when they don’t, however, the user may wish to kill them, and thus an in- terface to halt a runaway process is quite useful.\n\n• Wait: Sometimes it is useful to wait for a process to stop running; thus some kind of waiting interface is often provided.\n\n• Miscellaneous Control: Other than killing or waiting for a process, there are sometimes other controls that are possible. For example, most operating systems provide some kind of method to suspend a process (stop it from running for a while) and then resume it (con- tinue it running).\n\n• Status: There are usually interfaces to get some status information about a process as well, such as how long it has run for, or what state it is in.",
    "book_id": 55275242
  },
  {
    "id": 942312300,
    "text": "Finally, programs often access persistent storage devices too. Such I/O information might include a list of the ﬁles the process currently has open.",
    "book_id": 55275242
  },
  {
    "id": 942312281,
    "text": "In many operating systems, a common design paradigm is to separate high-level policies from their low-level mechanisms [L+75]. You can think of the mechanism as providing the answer to a how question about a system; for example, how does an operating system perform a context switch? The policy provides the answer to a which question; for example, which process should the operating system run right now? Separating the two allows one easily to change policies without having to rethink the mechanism and is thus a form of modularity, a general software design principle.",
    "book_id": 55275242
  },
  {
    "id": 942312237,
    "text": "pointer are used to manage the stack for function parameters, local vari- ables, and return addresses.",
    "book_id": 55275242
  },
  {
    "id": 942312226,
    "text": "Note that there are some particularly special registers that form part of this machine state. For example, the program counter (PC) (sometimes called the instruction pointer or IP) tells us which instruction of the pro- gram will execute next; similarly a stack pointer and associated frame",
    "book_id": 55275242
  },
  {
    "id": 942312216,
    "text": "Also part of the process’s machine state are registers; many instructions explicitly read or update registers and thus clearly they are important to the execution of the process.",
    "book_id": 55275242
  },
  {
    "id": 942312145,
    "text": "One obvious component of machine state that comprises a process is its memory. Instructions lie in memory; the data that the running pro- gram reads and writes sits in memory as well. Thus the memory that the process can address (called its address space) is part of the process.",
    "book_id": 55275242
  },
  {
    "id": 942311899,
    "text": "To understandwhat constitutes a process, we thus have to understand its machine state: what a program can read or update when it is running. At any given time, what parts of the machine are important to the execu- tion of this program?",
    "book_id": 55275242
  },
  {
    "id": 942311890,
    "text": "The abstraction provided by the OS of a running program is something we will call a process.",
    "book_id": 55275242
  },
  {
    "id": 942311876,
    "text": "On top of these mechanisms resides some of the intelligence in the OS, in the form of policies. Policies are algorithms for making some kind of decision within the OS. For example, given a number of possi- ble programs to run on a CPU, which program should the OS run? A scheduling policy in the OS will make this decision, likely using histori- cal information (",
    "book_id": 55275242
  },
  {
    "id": 942311747,
    "text": "which gives the OS the ability to stop running one program and start running another on a given CPU; this time-sharing mechanism is employed by all modern OSes.",
    "book_id": 55275242
  },
  {
    "id": 942311585,
    "text": "Time sharing is a basic technique used by an OS to share a resource. By allowing the resource to be used for a little while by one entity, and then a little while by another, and so forth, the resource in question (e.g., the CPU, or a network link) can be shared by many. The counterpart of time sharing is space sharing, where a resource is divided (in space) among those who wish to use it.",
    "book_id": 55275242
  },
  {
    "id": 942311573,
    "text": "To implement virtualization of the CPU, and to implement it well, the OS will need both some low-level machinery and some high-level in- telligence. We call the low-level machinery mechanisms; mechanisms are low-level methods or protocols that implement a needed piece of functionality",
    "book_id": 55275242
  },
  {
    "id": 942311548,
    "text": "The OS creates this illusion by virtualizing the CPU. By running one process, then stopping it and running another, and so forth, the OS can promote the illusion that many virtual CPUs exist when in fact there is only one physical CPU (or a few). This basic technique, known as time sharing of the CPU, allows users to run as many concurrent processes as they would like; the potential cost is performance, as each will run more slowly if the CPU(s) must be shared.",
    "book_id": 55275242
  },
  {
    "id": 942309844,
    "text": "The deﬁnition of a process, infor- mally, is quite simple: it is a running program [V+65,BH70]. The program itself is a lifeless thing: it just sits there on the disk, a bunch of instructions (and maybe some static data)",
    "book_id": 55275242
  },
  {
    "id": 941745405,
    "text": "Systems: Just Libraries In the beginning, the operating system didn’t do too much. Basically, it was just a set of l",
    "book_id": 55197535
  },
  {
    "id": 941741903,
    "text": "TI",
    "book_id": 55197535
  },
  {
    "id": 941198868,
    "text": "Updating nested arrays without mutation can get a little bit repetitive. [Just as with objects](https://react.dev/learn/updating-objects-in-state#write-concise-update-logic-with-immer):\n\n•   Generally, you shouldn’t need to update state more than a couple of levels deep. If your state objects are very deep, you might want to [restructure them differently](https://react.dev/learn/choosing-the-state-structure#avoid-deeply-nested-state) so that they are flat.\n•   If you don’t want to change your state structure, you might prefer to use [Immer](https://github.com/immerjs/use-immer), which lets you write using the convenient but mutating syntax and takes care of producing the copies for you.",
    "book_id": 55213866
  },
  {
    "id": 941198840,
    "text": "You can use `map` to substitute an old item with its updated version without mutation.",
    "book_id": 55213866
  },
  {
    "id": 941198819,
    "text": "**When updating nested state, you need to create copies from the point where you want to update, and all the way up to the top level.** Let’s see how this works.",
    "book_id": 55213866
  },
  {
    "id": 941198678,
    "text": "Objects are not *really* located “inside” arrays. They might appear to be “inside” in code, but each object in an array is a separate value, to which the array “points”. This is why you need to be careful when changing nested fields like `list[0]`. Another person’s artwork list may point to the same element of the array!",
    "book_id": 55213866
  },
  {
    "id": 941198609,
    "text": "It is particularly common to want to replace one or more items in an array. Assignments like `arr[0] = 'bird'` are mutating the original array, so instead you’ll want to use `map` for this as well.\n\nTo replace an item, create a new array with `map`. Inside your `map` call, you will receive the item index as the second argument. Use it to decide whether to return the original item (the first argument) or something else:",
    "book_id": 55213866
  },
  {
    "id": 941198599,
    "text": "If you want to change some or all items of the array, you can use `map()` to create a **new** array. The function you will pass to `map` can decide what to do with each item, based on its data or its index (or both).",
    "book_id": 55213866
  },
  {
    "id": 941198573,
    "text": "Here, `artists.filter(a => a.id !== artist.id)` means “create an array that consists of those `artists` whose IDs are different from `artist.id`”. In other words, each artist’s “Delete” button will filter *that* artist out of the array, and then request a re-render with the resulting array. Note that `filter` does not modify the original array.",
    "book_id": 55213866
  },
  {
    "id": 941198532,
    "text": "Instead, every time you want to update an array, you’ll want to pass a *new* array to your state setting function. To do that, you can create a new array from the original array in your state by calling its non-mutating methods like `filter()` and `map()`. Then you can set your state to the resulting new array.",
    "book_id": 55213866
  },
  {
    "id": 941198529,
    "text": "In JavaScript, arrays are just another kind of object. [Like with objects](https://react.dev/learn/updating-objects-in-state), **you should treat arrays in React state as read-only.** This means that you shouldn’t reassign items inside an array like `arr[0] = 'bird'`, and you also shouldn’t use methods that mutate the array, such as `push()` and `pop()`.",
    "book_id": 55213866
  },
  {
    "id": 941198496,
    "text": "Arrays are mutable in JavaScript, but you should treat them as immutable when you store them in state. Just like with objects, when you want to update an array stored in state, you need to create a new one (or make a copy of an existing one), and then set state to use the new array.",
    "book_id": 55213866
  },
  {
    "id": 941198476,
    "text": "The `draft` provided by Immer is a special type of object, called a [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy), that “records” what you do with it. This is why you can mutate it freely as much as you like! Under the hood, Immer figures out which parts of the `draft` have been changed, and produces a completely new object that contains your edits.",
    "book_id": 55213780
  },
  {
    "id": 941198442,
    "text": "If your state is deeply nested, you might want to consider [flattening it.](https://react.dev/learn/choosing-the-state-structure#avoid-deeply-nested-state) But, if you don’t want to change your state structure, you might prefer a shortcut to nested spreads. [Immer](https://github.com/immerjs/use-immer) is a popular library that lets you write using the convenient but mutating syntax and takes care of producing the copies for you. With Immer, the code you write looks like you are “breaking the rules” and mutating an object:",
    "book_id": 55213780
  },
  {
    "id": 941198118,
    "text": "Note that the `...` spread syntax is “shallow”—it only copies things one level deep. This makes it fast, but it also means that if you want to update a nested property, you’ll have to use it more than once.",
    "book_id": 55213780
  },
  {
    "id": 941198080,
    "text": "The reliable way to get the behavior you’re looking for is to create a new object and pass it to `setPerson`. But here, you want to also **copy the existing data into it** because only one of the fields has changed:\n\n    setPerson({  firstName: e.target.value, // New first name from the input  lastName: person.lastName,  email: person.email});\n\nYou can use the `...` [object spread](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals) syntax so that you don’t need to copy every property separately.",
    "book_id": 55213780
  },
  {
    "id": 941198051,
    "text": "In the previous example, the `position` object is always created fresh from the current cursor position. But often, you will want to include *existing* data as a part of the new object you’re creating. For example, you may want to update *only one* field in a form, but keep the previous values for all other fields.",
    "book_id": 55213780
  },
  {
    "id": 941197616,
    "text": "Mutation is only a problem when you change *existing* objects that are already in state. Mutating an object you’ve just created is okay because *no other code references it yet.* Changing it isn’t going to accidentally impact something that depends on it. This is called a “local mutation”. You can even do local mutation [while rendering.](https://react.dev/learn/keeping-components-pure#local-mutation-your-components-little-secret) Very convenient and completely okay!",
    "book_id": 55213780
  },
  {
    "id": 941197530,
    "text": "To actually [trigger a re-render](https://react.dev/learn/state-as-a-snapshot#setting-state-triggers-renders) in this case, **create a *new* object and pass it to the state setting function:**",
    "book_id": 55213780
  },
  {
    "id": 941197438,
    "text": "In other words, you should **treat any JavaScript object that you put into state as read-only.**",
    "book_id": 55213780
  },
  {
    "id": 941197431,
    "text": "However, although objects in React state are technically mutable, you should treat them **as if** they were immutable—like numbers, booleans, and strings. Instead of mutating them, you should always replace them.",
    "book_id": 55213780
  },
  {
    "id": 941197416,
    "text": "Now consider an object in state:\n\n    const [position, setPosition] = useState({ x: 0, y: 0 });\n\nTechnically, it is possible to change the contents of *the object itself*. **This is called a mutation:**",
    "book_id": 55213780
  },
  {
    "id": 941197398,
    "text": "State can hold any kind of JavaScript value, including objects. But you shouldn’t change objects that you hold in the React state directly. Instead, when you want to update an object, you need to create a new one (or make a copy of an existing one), and then set the state to use that copy.",
    "book_id": 55213780
  },
  {
    "id": 941197149,
    "text": "After the event handler completes, React will trigger a re-render. During the re-render, React will process the queue. Updater functions run during rendering, so **updater functions must be [pure](https://react.dev/learn/keeping-components-pure)** and only *return* the result. Don’t try to set state from inside of them or run other side effects. In Strict Mode, React will run each updater function twice (but discard the second result) to help you find mistakes.",
    "book_id": 55213705
  },
  {
    "id": 941197131,
    "text": "To summarize, here’s how you can think of what you’re passing to the `setNumber` state setter:\n\n•   **An updater function** (e.g. `n => n + 1`) gets added to the queue.\n•   **Any other value** (e.g. number `5`) adds “replace with `5`” to the queue, ignoring what’s already queued.",
    "book_id": 55213705
  },
  {
    "id": 941197060,
    "text": "Here, `n => n + 1` is called an **updater function.** When you pass it to a state setter:\n\n1.  React queues this function to be processed after all the other code in the event handler has run.\n2.  During the next render, React goes through the queue and gives you the final updated state.",
    "book_id": 55213705
  },
  {
    "id": 941197034,
    "text": "It is an uncommon use case, but if you would like to update the same state variable multiple times before the next render, instead of passing the *next state value* like `setNumber(number + 1)`, you can pass a *function* that calculates the next state based on the previous one in the queue, like `setNumber(n => n + 1)`. It is a way to tell React to “do something with the state value” instead of just replacing it.",
    "book_id": 55213705
  },
  {
    "id": 941196986,
    "text": "**React does not batch across *multiple* intentional events like clicks**—each click is handled separately. Rest assured that React only does batching when it’s generally safe to do. This ensures that, for example, if the first button click disables a form, the second click would not submit it again.",
    "book_id": 55213705
  },
  {
    "id": 941196949,
    "text": "This lets you update multiple state variables—even from multiple components—without triggering too many [re-renders.](https://react.dev/learn/render-and-commit#re-renders-when-state-updates) But this also means that the UI won’t be updated until *after* your event handler, and any code in it, completes. This behavior, also known as **batching,** makes your React app run much faster. It also avoids dealing with confusing “half-finished” renders where only some of the variables have been updated.",
    "book_id": 55213705
  },
  {
    "id": 941196925,
    "text": "But there is one other factor at play here. **React waits until *all* code in the event handlers has run before processing your state updates.** This is why the re-render only happens *after* all these `setNumber()` calls.\n\nThis might remind you of a waiter taking an order at the restaurant. A waiter doesn’t run to the kitchen at the mention of your first dish! Instead, they let you finish your order, let you make changes to it, and even take orders from other people at the table.",
    "book_id": 55213705
  },
  {
    "id": 941196903,
    "text": "Setting a state variable will queue another render. But sometimes you might want to perform multiple operations on the value before queueing the next render. To do this, it helps to understand how React batches state updates.",
    "book_id": 55213705
  },
  {
    "id": 941196680,
    "text": "**React keeps the state values “fixed” within one render’s event handlers.** You don’t need to worry whether the state has changed while the code is running.\n\nBut what if you wanted to read the latest state before a re-render? You’ll want to use a [state updater function](https://react.dev/learn/queueing-a-series-of-state-updates), covered on the next page!",
    "book_id": 55213654
  },
  {
    "id": 941196495,
    "text": "When React re-renders a component:\n\n1.  React calls your function again.\n2.  Your function returns a new JSX snapshot.\n3.  React then updates the screen to match the snapshot your function returned.",
    "book_id": 55213654
  },
  {
    "id": 941196493,
    "text": "Unlike a photograph or a movie frame, the UI “snapshot” you return is interactive. It includes logic like event handlers that specify what happens in response to inputs. React updates the screen to match this snapshot and connects the event handlers. As a result, pressing a button will trigger the click handler from your JSX.",
    "book_id": 55213654
  },
  {
    "id": 941196464,
    "text": "[“Rendering”](https://react.dev/learn/render-and-commit#step-2-react-renders-your-components) means that React is calling your component, which is a function. The JSX you return from that function is like a snapshot of the UI in time. Its props, event handlers, and local variables were all calculated **using its state at the time of the render.**",
    "book_id": 55213654
  },
  {
    "id": 941196433,
    "text": "You might think of your user interface as changing directly in response to the user event like a click. In React, it works a little differently from this mental model. On the previous page, you saw that [setting state requests a re-render](https://react.dev/learn/render-and-commit#step-1-trigger-a-render) from React. This means that for an interface to react to the event, you need to *update the state*.",
    "book_id": 55213654
  },
  {
    "id": 941196407,
    "text": "State variables might look like regular JavaScript variables that you can read and write to. However, state behaves more like a snapshot. Setting it does not change the state variable you already have, but instead triggers a re-render.",
    "book_id": 55213654
  },
  {
    "id": 941196343,
    "text": "After rendering (calling) your components, React will modify the DOM.\n\n•   **For the initial render,** React will use the [`appendChild()`](https://developer.mozilla.org/docs/Web/API/Node/appendChild) DOM API to put all the DOM nodes it has created on screen.\n•   **For re-renders,** React will apply the minimal necessary operations (calculated while rendering!) to make the DOM match the latest rendering output.\n\n**React only changes the DOM nodes if there’s a difference between renders.**",
    "book_id": 55213624
  },
  {
    "id": 941196327,
    "text": "Rendering must always be a [pure calculation](https://react.dev/learn/keeping-components-pure):\n\n•   **Same inputs, same output.** Given the same inputs, a component should always return the same JSX. (When someone orders a salad with tomatoes, they should not receive a salad with onions!)\n•   **It minds its own business.** It should not change any objects or variables that existed before rendering. (One order should not change anyone else’s order.)\n\nOtherwise, you can encounter confusing bugs and unpredictable behavior as your codebase grows in complexity. When developing in “Strict Mode”, React calls each component’s function twice, which can help surface mistakes caused by impure functions.",
    "book_id": 55213624
  },
  {
    "id": 941196317,
    "text": "•   **During the initial render,** React will [create the DOM nodes](https://developer.mozilla.org/docs/Web/API/Document/createElement) for `<section>`, `<h1>`, and three `<img>` tags.\n•   **During a re-render,** React will calculate which of their properties, if any, have changed since the previous render. It won’t do anything with that information until the next step, the commit phase.",
    "book_id": 55213624
  },
  {
    "id": 941196295,
    "text": "This process is recursive: if the updated component returns some other component, React will render *that* component next, and if that component also returns something, it will render *that* component next, and so on. The process will continue until there are no more nested components and React knows exactly what should be displayed on screen.",
    "book_id": 55213624
  },
  {
    "id": 941196286,
    "text": "After you trigger a render, React calls your components to figure out what to display on screen. **“Rendering” is React calling your components.**\n\n•   **On initial render,** React will call the root component.\n•   **For subsequent renders,** React will call the function component whose state update triggered the render.",
    "book_id": 55213624
  },
  {
    "id": 941196269,
    "text": "Once the component has been initially rendered, you can trigger further renders by updating its state with the [`set` function.](https://react.dev/reference/react/useState#setstate) Updating your component’s state automatically queues a render. (You can imagine these as a restaurant guest ordering tea, dessert, and all sorts of things after putting in their first order, depending on the state of their thirst or hunger.)",
    "book_id": 55213624
  },
  {
    "id": 941196249,
    "text": "When your app starts, you need to trigger the initial render. Frameworks and sandboxes sometimes hide this code, but it’s done by calling [`createRoot`](https://react.dev/reference/react-dom/client/createRoot) with the target DOM node, and then calling its `render` method with your component:",
    "book_id": 55213624
  },
  {
    "id": 941196237,
    "text": "There are two reasons for a component to render:\n\n1.  It’s the component’s **initial render.**\n2.  The component’s (or one of its ancestors’) **state has been updated.**",
    "book_id": 55213624
  },
  {
    "id": 941196228,
    "text": "Imagine that your components are cooks in the kitchen, assembling tasty dishes from ingredients. In this scenario, React is the waiter who puts in requests from customers and brings them their orders. This process of requesting and serving UI has three steps:\n\n1.  **Triggering** a render (delivering the guest’s order to the kitchen)\n2.  **Rendering** the component (preparing the order in the kitchen)\n3.  **Committing** to the DOM (placing the order on the table)",
    "book_id": 55213624
  },
  {
    "id": 941196211,
    "text": "Before your components are displayed on screen, they must be rendered by React. Understanding the steps in this process will help you think about how your code executes and explain its behavior.",
    "book_id": 55213624
  },
  {
    "id": 941196173,
    "text": "State is local to a component instance on the screen. In other words, **if you render the same component twice, each copy will have completely isolated state!** Changing one of them will not affect the other.",
    "book_id": 55213557
  },
  {
    "id": 941196115,
    "text": "It is a good idea to have multiple state variables if their state is unrelated, like `index` and `showMore` in this example. But if you find that you often change two state variables together, it might be easier to combine them into one. For example, if you have a form with many fields, it’s more convenient to have a single state variable that holds an object than state variable per field. Read [Choosing the State Structure](https://react.dev/learn/choosing-the-state-structure) for more tips.",
    "book_id": 55213557
  },
  {
    "id": 941196108,
    "text": "You can have as many state variables of as many types as you like in one component. This component has two state variables, a number `index` and a boolean `showMore` that’s toggled when you click “Show details”:",
    "book_id": 55213557
  },
  {
    "id": 941195957,
    "text": "The only argument to `useState` is the **initial value** of your state variable. In this example, the `index`’s initial value is set to `0` with `useState(0)`.\n\nEvery time your component renders, `useState` gives you an array containing two values:\n\n1.  The **state variable** (`index`) with the value you stored.\n2.  The **state setter function** (`setIndex`) which can update the state variable and trigger React to render the component again.",
    "book_id": 55213557
  },
  {
    "id": 941195815,
    "text": "When you call [`useState`](https://react.dev/reference/react/useState), you are telling React that you want this component to remember something:",
    "book_id": 55213557
  },
  {
    "id": 941195809,
    "text": "In React, `useState`, as well as any other function starting with “`use`”, is called a Hook.\n\n*Hooks* are special functions that are only available while React is [rendering](https://react.dev/learn/render-and-commit#step-1-trigger-a-render) (which we’ll get into in more detail on the next page). They let you “hook into” different React features.\n\nState is just one of those features, but you will meet the other Hooks later.",
    "book_id": 55213557
  },
  {
    "id": 941195647,
    "text": "To update a component with new data, two things need to happen:\n\n1.  **Retain** the data between renders.\n2.  **Trigger** React to render the component with new data (re-rendering).\n\nThe [`useState`](https://react.dev/reference/react/useState) Hook provides those two things:\n\n1.  A **state variable** to retain the data between renders.\n2.  A **state setter function** to update the variable and trigger React to render the component again.",
    "book_id": 55213557
  },
  {
    "id": 941195580,
    "text": "Components often need to change what’s on the screen as a result of an interaction. Typing into the form should update the input field, clicking “next” on an image carousel should change which image is displayed, clicking “buy” should put a product in the shopping cart. Components need to “remember” things: the current input value, the current image, the shopping cart. In React, this kind of component-specific memory is called *state*.",
    "book_id": 55213557
  },
  {
    "id": 940952250,
    "text": "Fortunately for UNIX, a young Finnish hacker named Linus Torvalds de- cided to write his own version of UNIX which borrowed heavily on the principles and ideas behind the original system, but not from the code base, thus avoiding issues of legality. He enlisted help from many others around the world, took advantage of the sophisticated GNU tools that already existed [G85], and soon Linux was born (as well as the modern open-source software movement).",
    "book_id": 55197535
  },
  {
    "id": 940952135,
    "text": "The UNIX environment was friendly for programmers and developers alike, also providing a compiler for the new C programming language. Making it easy for programmers to write their own programs, as well as share them, made UNIX enormously popular. And it probably helped a lot that the authors gave out copies for free to anyone who asked, an early form of open-source software.\n\nAlso of critical importance was the accessibility and readability of the code. Having a beautiful, small kernel written in C invited others to play with the kernel, adding new and cool features.",
    "book_id": 55197535
  },
  {
    "id": 940952092,
    "text": "Underlying the original “Bell Labs” UNIX was the unifying principle of building small powerful programs that could be connected together to form larger workﬂows. The shell, where you type commands, provided primitives such as pipes to enable such meta-level programming, and thus it became easy to string together programs to accomplish a big- ger task.",
    "book_id": 55197535
  },
  {
    "id": 940951924,
    "text": "In particular, multiprogramming became commonplace due to the de- sire to make better use of machine resources. Instead of just running one job at a time, the OSwould load a number of jobs intomemory and switch rapidly between them, thus improving CPU utilization. This switching was particularly important because I/O devices were slow; having a pro- gram wait on the CPU while its I/O was being serviced was a waste of CPU time. Instead, why not switch to another job and run it for a while?",
    "book_id": 55197535
  },
  {
    "id": 940951821,
    "text": "When a system call is initiated (usually through a special hardware instruction called a trap), the hard- ware transfers control to a pre-speciﬁed trap handler (that the OS set up previously) and simultaneously raises the privilege level to kernel mode. In kernel mode, the OS has full access to the hardware of the system and thus can do things like initiate an I/O request or make more memory available to a program. When the OS is done servicing the request, it passes control back to the user via a special return-from-trap instruction, which reverts to user mode while simultaneously passing control back to where the application left off.",
    "book_id": 55197535
  },
  {
    "id": 940951800,
    "text": "The key difference between a system call and a procedure call is that a system call transfers control (i.e., jumps) into the OS while simultane- ously raising the hardware privilege level. User applications run inwhat is referred to as user mode which means the hardware restricts what ap- plications can do",
    "book_id": 55197535
  }
]